[{"categories":null,"content":"Git的安装和配置 下载Git 配置环境变量 检验安装成功 配置全局信息 git config --global user.name \"RobKing\" //用户名 git config --global user.email \"2768817839@qq.com\" //邮箱 git config -l //查看全局信息 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"配置代理 git config --global https.proxy http://127.0.0.1:7890 //配置代理 git config --global --unset http.proxy //取消http代理 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:1","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Git指令的使用 git log查看commit日志 git log --oneline --graph --decorate --all查看节点树 git reset --hard commit_id 回退到指定id （指定版本） ​ 此操作结束之后 本地代码和远程仓库代码 都会回退到 原来的版本 git reset --hard origin/dev 取消当前改动(回退指定id的改动），重置到库的最新版本（取消回退） ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"将项目上传到Github上 进入Github首页，点击New repository新建一个项目（添加一个Readme） 在项目的根路径下git clone + 项目名（下载指定分支 git clone -b dev ***） 更新代码提交 git add . git commit -m \"first commit\" git push origin master(main) ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"本地项目与Github同步 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"添加SSH KEY ssh-keygen -t rsa -C “2768817839@qq.com” 成功生成SSH key了，可以到C:/Users/你的用户账号/.ssh文件夹下看 Linux下可以cd ~./ssh 复制.ssh文件夹下id_rsa.pub文件的内容添加到github 测试ssh连接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:1","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"关联本地库和远程库 git remote add origin git@github.com:RobKing9/CargoManageSystem.git 如果ssh被占用 将导致或者如果项目是http协议 需要删除远程git仓库，执行git remote rm origin 执行指令 git remote -v查看当前情况 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:2","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"拉取最新代码 参看版本差异可直接 git log -p master ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:3","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Git分支管理 将远程仓库的分支信息拉取到本地仓库git fetch 在本地创建新分支 git branch [分支名] 切换分支 git checkout [分支名] git branch 查看本地分支 git branch -a 查看所有分支 git checkout -b main origin/main 创建并切换分支 删除分支 本地：git branch -d master 远程库：git push -d origin master或者git push origin :master ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:5:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":".gitignore文件的使用 如果项目已经push上去了 但是没有忽略 ，增加 .gitignore 文件 .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: git rm -r --cached . 再次执行 git add . --\u003egit commit -m \"update .gitignore\" --\u003e git push origin dev *.a 表示忽略所有 .a 结尾的文件 !lib.a 表示但lib.a除外 /TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹； .idea/ doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 表示忽略根目录下的bin文件 /*.c: 表示忽略cat.c，不忽略 build/cat.c debug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj **/foo: 表示忽略/foo,a/foo,a/b/foo等 a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等 !/bin/run.sh 表示不忽略bin目录下的run.sh文件 *.log: 表示忽略所有 .log 文件 config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹 *.zip 表示过滤所有.zip文件 /mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下： !*.zip !/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？ 想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：： /mtk/* !/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！ 注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ---------------------------------------------------------------------------------- 还有一些规则如下： fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； /* !.gitignore !/fw/ /fw/* !/fw/bin/ !/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:6:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"git commit message 编写指南 Head+Body+Footer ；Head: type • feat：新功能（feature） • fix：修补bug • docs：文档（documentation） • style： 格式（不影响代码运行的变动） • refactor：重构（即不是新增功能，也不是修改bug的代码变动） • test：增加测试 • chore：构建过程或辅助工具的变动 scope subject ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:7:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"使用tree命令生成项目目录树 下载 tree 命令的二进制包，安装 tree 命令工具;地址，选择下载 Binaries zip 文件 解压压缩包，找到压缩包内的 bin 目录，将 bin 目录下的 tree.exe 复制； 找到Git的Bin目录，将 tree.exe 粘贴到该目录下，安装即完成 tree -L 5 -I \"node_modules|dist|dist.zip\" \u003etree.txt 将目录结构导出 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:8:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"使用Git遇到的Bug及解决方法 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"解决git clone速度慢的方法 //这是我们要clone的 git clone https://github.com/Hackergeek/architecture-samples //使用镜像 git clone https://github.com.cnpmjs.org/Hackergeek/architecture-samples //或者使用镜像 git clone https://git.sdut.me/Hackergeek/architecture-samples 几个可用的镜像源 https://hub.fastgit.org](https://hub.fastgit.org/) https://github.com.cnpmjs.org](https://github.com.cnpmjs.org/) https://github.bajins.com](https://github.bajins.com/) https://github.rc1844.workers.dev](https://github.rc1844.workers.dev/) ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:1","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"合并代码遇到error: Your local changes to the following files would be overwritten by merge 解决方法 执行git stash 本地刚才修改的代码将会被暂时封存起来 git merge origin/feature-feed-user 重新合并 git stash pop 服务器上的代码更新到了本地，而且你本地修改的代码也没有被覆盖 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:2","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"提交代码遇到To github.com:RobKing9/ByteGopher_SimpleDouyin.git ! [rejected] dev -\u003e dev (non-fast-forward) error: failed to push some refs to ‘github.com:RobKing9/ByteGopher_SimpleDouyin.git’ 解决方法 说明远程仓库的代码比本地先更新 遇到了冲突 无法提交 首先把远程仓库最新的代码拉下来 （参考上面 本地项目与Github同步的拉取代码） 手动解决冲突 留下需要的代码 删除不需要的 再次执行 git add . --\u003egit commit -m \"\" --\u003e git push origin dev ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:3","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"git-修改commit信息 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:4","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"添加远程仓库遇到fatal: unsafe repository (‘D:/AGolang/src/Aproject/ByteGopher_SimpleDouyin’ is owned by someone else) 解决方法 git config --global --add safe.directory * 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:5","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"操作系统面试总结 | 2022最新 | 斩获大厂offer ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"github链接欢迎star！ ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"我的博客 进程，线程，协程 简述线程和进程的区别和联系 进程的状态与状态转换 什么是孤儿进程？僵尸进程? 并发和并行有什么区别？ 什么是内核态和用户态？如何实现两者之间的相互转换？ 锁，同步，通信 什么是死锁？死锁产生的必要条件？ 如何解决死锁问题？ 你了解乐观锁和悲观锁吗？ 进程间通信的方式有哪些？ 线程同步有哪些方式？ 存储管理 了解虚拟内存吗？ 什么是分页？什么是分段？两者有什么区别？ 软链接和硬链接有什么区别？ 页面置换算法有哪些 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"进程，线程，协程 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"简述线程和进程，协程的区别和联系 区别 进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。 一个进程可以有多个线程，但是一个线程只能属于一个进程。一个线程可以有多个协程，一个进程也可以有多个协程。 进程的创建需要系统分配内存和CPU等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。 进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。 线程和进程都是同步机制，而协程是异步机制。 协程不被操作系统内核管理，而完全是由程序控制。协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。 联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。一个线程可以有多个协程，一个进程也可以有多个协程。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:1","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"进程的状态与状态转换 进程在运行时有三种基本状态：就绪态、运行态和阻塞态。 执行：进程分到CPU时间片，可以执行 就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行 阻塞：有IO事件或者等待其他资源 各状态之间的转换： 就绪→执行 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。 执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 执行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。 阻塞→就绪 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:2","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是孤儿进程？僵尸进程? 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。 僵尸进程： 进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:3","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"并发和并行有什么区别？ 并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。 并行就是在同一时刻，有多个任务在执行。这个是物理上的多个进程同时进行。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:4","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是内核态和用户态？如何实现两者之间的相互转换？ 为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。 内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。 用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。 用户程序运行在用户态,操作系统内核运行在内核态。 处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。 异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。 外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:5","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"锁，同步，通信 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是死锁？死锁产生的必要条件？ 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。产生死锁需要满足下面四个条件： 互斥：一个资源一次只能被一个进程使用； 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源； 非抢占条件：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放； 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:1","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"如何解决死锁问题？ 解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下: 资源一次性分配，这样就不会再有请求了（破坏请求条件）。 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。 可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:2","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"你了解乐观锁和悲观锁吗？ 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。适用于多读场景。 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。适用于多写的场景。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:3","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"进程间通信的方式有哪些？ 管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 消息队列：消息队列是消息的链表，存放在内核中并由消息队列标识符标识 信号(Signal)：信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。 共享内存：共享内存是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。共享内存是最快的IPC方式 信号量(Semaphore)：信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。 套接字(Socket)：套接口也是一种进程间通信机制，它可用于不同主机间的进程通信 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:4","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"线程同步有哪些方式？ 信号量：允许统一时刻多个线程访问同一个资源，但需要控制统一时刻访问此资源的最大线程数量 互斥量：实际上是信号量的一种特殊情况，允许统一时刻只有一个线程访问同一个资源 信号，也叫事件：通过通知操作的方式来保证多线程同步，还可以方便实现多线程优先级的比较操作 多线程锁实现多线程同步 互斥锁：保护临界区，确保同一时间，只有一个线程访问数据。如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁 自旋锁：在获取到锁之前，一直处于循环检测保持者是否已经释放了锁。与互斥锁的区别是，在申请自旋锁时，线程处于忙等状态，而非挂起状态 信号量：一个计数器，用来控制多个进程对共享资源的访问。互斥锁为信号量的一个特殊情况。 读写锁：高级别锁，区分读和写，符合条件时，允许多个线程访问对象。处于读锁时，允许其他线程和本线程的读锁，但不允许写锁。处于写锁时，任何锁操作都会睡眠等待 递归锁：递归锁是互斥锁的一个特殊情况。同样地，只能由一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时，反复对锁进行加锁操作 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:5","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"内存管理 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"了解虚拟内存吗？ 每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页；但不需要所有的页都在物理内存中，当程序访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:1","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是分页？什么是分段？两者有什么区别？ 页式存储：把内存空间划分为大小相等且固定的块，因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻； 段页式存储：用户进程先按段划分，段内再按页划分，内存 划分和分配 按页。 分页主要用于提高内存利用率，实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:2","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"软链接和硬链接有什么区别？ 软链接可以理解为 Windows 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径。 硬链接就是记录着文件名和源文件的inode编号。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:3","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"页面置换算法有哪些 在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断，将磁盘中该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下： 先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。性能较差，调出的页面可能是经常访问的 LRU算法：置换最近一段时间以来最长时间未访问过的页面。 LFU算法：缺页时，置换访问次数最少的页面 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:4","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"参考资料 操作系统八股文背诵版 操作系统常见面试题（2021最新版） 操作系统最强面经面试题总结 | 春招秋招必备 | Offer收割 超全面的后端开发C/C++面经整理分享含详细参考答案 包括简历分享 JobInterviewGuide/interview_guide ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:6:0","tags":null,"title":"操作系统面试总结\t | 2022最新 | 斩获大厂offer","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"计算机网络 github地址 HTTP，HTTPS，DNS协议 OSI七层模型 介绍一下OSI七层模型和TCP五层模型？ TCP,UDP,IP协议分别属于什么层？ HTTP版本1.0,1.1,2.0 http/1.0和http/1.1有什么区别？ http短连接和长连接有什么区别？ http/2.0相比较与http/1.1有什么特性？ HTTP报文结构，请求方法，状态码 http请求方法有哪些？ get和post方法有什么区别？ http状态码200,403等等表示什么意思？ HTTP和HTTPS HTTP和HTTPS的区别？ 请简述TLS技术的工作原理？ DNS服务与安全 请简述域名系统DNS的工作流程？ 你了解DNS攻击吗？是什么原理？ TCP，UDP，IP协议 传输层协议 请简述TCP和UDP的区别？ TCP连接及释放 请简述三次握手的过程？为什么两次不行？ TCP三次握手时的第一次的seq序号是怎样产生的字节提前批 请简述四次挥手的过程？为什么三次不行？ TIME_WAIT为什么是2MSL，而不是1MSL或者3MSL？ TCP的可靠连接和粘包 请简述TCP协议的滑动窗口？ 请简述TCP协议的拥塞控制及算法？ 拥塞控制和流量控制的区别 请介绍一下TCP的粘包现象以及如何避免 请简述SYNflood攻击的原理 浏览器中输入一个网址后，具体发生了什么 HTTP，HTTPS，DNS协议 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"OSI七层模型 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"介绍一下OSI七层模型和TCP五层模型？ ​ OSI七层模型从上到下依次为： 应用层：为应用程序提供网络服务； 表示层：数据格式转换、数据压缩和数据加密； 会话层：建立、断开和维护通信链接； 传输层：为上层协议提供端到端的可靠传输； 网络层：寻址和路由； 数据链路层：定义通过通信媒介互连的设备之间传输的规范； 物理层：利用物理传输介质为数据链路层提供物理连接。 ​ TCP五层模型相比OSI七层模型，将OSI的应用层、表示层和会话层合为一层：应用层，其他不变。 ​ TCP/IP五层协议包括：应用层，传输层，网络层，数据链路层，物理层 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP,UDP,IP协议分别属于什么层？ ​ TCP，UDP协议属于传输层 ​ IP协议属于网络层 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP版本1.0,1.1,2.0 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http/1.0和http/1.1有什么区别？ ​ HTTP1.1默认开启长连接。在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 ​ 支持管道（pipeline）网络传输。只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 ​ http/1.1的缺点是服务端无法主动push ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http短连接和长连接有什么区别？ ​ HTTP中的长连接短连接指HTTP底层TCP的连接。 ​ 短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。 ​ 长连接：如果HTTP头部带有参数keep-alive，即开启长连接，网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http/2.0相比较与http/1.1有什么特性？ 多路复用。允许同时发起多重的“请求-响应”消息 头部压缩。对消息头采用 Hpack 算法进行压缩传输，能够节省消息头占用的网络流量 服务端推送。服务器端能够更快的把资源推送到客户端 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:3","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP报文结构，请求方法，状态码 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http请求方法有哪些？ GET: 从服务器获取资源 POST: 在服务器新建资源 PUT: 在服务器更新资源 DELETE: 在服务器删除资源 HEAD: 获取资源的元数据 OPTIONAL: 查询对指定的资源支持的方法 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"get和post方法有什么区别？ ​ Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。 ​ Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http状态码200,403等等表示什么意思？ 1XX：接收的信息正在处理 2XX：请求正常处理完毕 3XX：重定向 4XX：客户端错误 5XX：服务端错误 200：OK 请求被正常处理 204：No Content 请求被受理但没有资源可以返回 301：永久性重定向 302：临时重定向 304：Not Modified 所请求的资源未修改，服务器返回此状态码，不返回任何资源 400：Bad Request 客户端请求报文语法有误，服务器无法识别 401：Unauthorized 请求需要认证 403：Forbidden 请求的对应资源禁止被访问 404：Not Found 服务器无法找到对应资源 500：Internal Server Error 服务器内部错误 502：Bad Gateway 网关或者代理服务器请求时，从远程服务器接收到一个无效的响应 503：Service Unavailable 服务器正忙 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:3","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP和HTTPS ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP和HTTPS的区别？ http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。 https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TLS技术的工作原理？ SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。 可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"DNS服务与安全 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述域名系统DNS的工作流程？ 客户端发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给本地dns服务器 本地服务器没有找到客户端查询的信息，就会将此请求发送到根域名dns服务器 根域名服务器解析客户端请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户端的dns服务器 客户端的dns服务器根据返回的信息接着访问下一级的dns服务器 这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息 客户端的本地的dns服务器会将查询结果返回给我们的客户端 客户端根据得到的ip信息访问目标主机，完成解析过程 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述cookie和session？ HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。 session用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"你了解DNS攻击吗？是什么原理？ DNS攻击主要包括DNS劫持，DNS欺骗以及DDoS攻击。 DNS劫持：通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的DNS纪录指向到黑客可以控制的DNS服务器，然后通过在该DNS服务器上添加相应域名纪录，以至于访问该域名时，进入了黑客所指向的内容。 DNS欺骗：DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了。 DDoS攻击：DDoS是一种网络攻击手法，DNS服务器本质上也是程序，黑客通常利用程序中的漏洞使目标服务器的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 TCP，UDP，IP协议 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:3","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"传输层协议 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:6:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TCP和UDP的区别？ TCP作为面向流的协议，提供可靠的、面向连接的传输服务，并且提供点对点通信 UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:6:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP连接及释放 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述三次握手的过程？为什么两次不行？ 第一次握手:客户端将标志位SYN置为1，随机产生一个序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。 第二次握手:服务端收到数据包后将标志位SYN和 ACK都置为1，随机产生一个序列号seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了 假如TCP建立连接是两次握手的话，那么只要服务器有回应就建立连接；如果客户端因为网络问题发送了两次或者多次请求连接的信息，那么就会建立很多次不可靠的连接；另外如果服务器在返回给客户端的ACK数据包因为网络问题导致丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁，浪费服务器资源。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP三次握手时的第一次的seq序号是怎样产生的字节提前批 第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。 seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述四次挥手的过程？为什么三次不行？ 第一次挥手：客户端将标志位FIN置为1，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。 第三次挥手：服务端标志位FIN置为1，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。 如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:3","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TIME_WAIT为什么是2MSL，而不是1MSL或者3MSL？ TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。MSL即报文最大生存时间。 设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:4","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP的可靠连接和粘包 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TCP协议的滑动窗口？ TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，接收方通在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列，从而控制发送方的发送速度。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:1","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TCP协议的拥塞控制及算法？ 拥塞控制是为了防止过多的数据注入到网络中，这样可能使网络中的路由器或链路负载过重，拥塞控制也是控制发送者的流量，拥塞控制有四种算法，慢启动、拥塞避免，快速重传和快速恢复 （1）慢启动。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后以指数级翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd \u003e ssthresh 时），停止使用慢开始算法而改用拥塞避免算法 （2）拥塞避免。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。 （3）快速重传。如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。 （4）快速恢复。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:2","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"拥塞控制和流量控制的区别 拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:3","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"你了解ARQ协议吗？ ARQ协议，即自动重传请求（Automatic Repeat-reQuest），意思是如果发送方在发送后一段时间之内没有收到确认回执，它通常会重新发送。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:4","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请介绍一下TCP的粘包现象以及如何避免 TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个TCP报文中发出去的可能性。 可以简单的理解成发送端调用了两次send，接收端一个recv就把信息都读出来了。 导致TCP粘包的原因主要有两方面： 发送端等待缓冲区满才进行发送，造成粘包 接收方来不及接收缓冲区内的数据，造成粘包 避免粘包的措施： 通过编程，强制使TCP进行数据传送，不必等到缓冲区满 优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等 固定发送信息长度，或在两个信息之间加入分隔符。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:5","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述SYNflood攻击的原理 SYN Flood是一种拒绝服务（DDoS）攻击，其目的是通过消耗所有可用的服务器资源使服务器不可用于合法流量。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器机器上的所有可用端口，导致目标设备根本不响应合法流量。 原理是利用TCP连接三次握手的漏洞，使用欺骗性的IP地址，向目标服务器发送大量的SYN数据包 防范 第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数。 第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，并记录地址信息，以后从这个IP地址来的包会被一概丢弃。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:6","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"浏览器中输入一个网址后，具体发生了什么 首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址； 然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接； 接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送） 服务器对客户端发来的http请求进行处理，并返回响应； 客户端接收到http响应，将结果渲染展示给用户。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:7","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"参考资料 ​ 超全面的后端开发C/C++面经整理分享 ​ 计算机网络八股文背诵版 ​ 计算机网络面试题（含答案） ​ ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:9:0","tags":null,"title":"计算机网络面试总结","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"边无际 | Golang后端开发 | 2022.06.25 这算是我学习go语言来第一次参加面试。 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:0:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"一面 一面是在5月份左右 自我介绍 channel关闭了去读去写会出现什么问题？这个我回答的还不错 直接两道算法题，我直接蒙逼了。 第一道是 给一些括号 匹配成功返回true，失败返回false，括号匹配问题 第二道是传入字符串键值对（a=1,b=2），转化为map型（key：value），这个就很尴尬，因为对map的不熟悉，在初始化上出了错误 中间问了 索引二叉树的时间复杂度，没有回答上来 面试完算法题就结束了，我知道结果肯定寄了，虽然一开始也没有报太大的希望 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:1:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"二面 二面主要是笔试，二套试卷，一套是go语言相关的（30道选择题和一道算法题），一套是算法题（二道），总结如下： ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"第一套试卷（后端golang） golang基本结构 golang特性 go语言触发异常的场景 CSP模型 GMP 读写锁 线程进程协程 for循环 make和new的区别 指针 引用类型 select beego框架 Gin框架 Ginkgo GoStub Go vendor Go Mock 还有没写的就是代码运行结果相关的 然后就是一道 算法题 矩阵转置 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:1","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"第二套试卷（算法） 第一道算法题是判断两棵树是否相同 第二道是合并链表 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:2","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"二面总结 题目不算太难，选择题很多库都没见过，不熟悉，最后还是很顺利的通过了笔试 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:3","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"三面 过完二面笔试之后，第二天收到了答复，当天晚上七点就直接进行面试（三面）。以下是面试内容 自我介绍 为什么选择Golang？前景好，性能好，小而精 擅长做什么事情？做项目 聊天室项目怎么实现的？通过几个goroutine go语言的垃圾回收？这个项目怎么进行的？ 这个项目没有用到垃圾回收，是语言的特性。 了解docker？连接简单指令，部署了聊天室的服务器 使用什么网络框架？实现了什么东西？ 登录注册 登录注册是怎么实现的？校验信息，密码加密保存 怎么进行加密的？通过github上的包 看了github项目很多，介绍写的很好，怎么写出来的？参看README模板 写两道算法题，在showmebug网站 第一道是 通过管道实现生产者消费者模型，运行出来了 第二道是 将每个单词的首字母移到至单词结尾，并在单词结尾添加「so」。保留标点符号不变。 没太写出来 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:3:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"心得 面试的这家公司非常注重算法，也狠狠的打击了我，让我有动力去提升我的算法能力 希望自己面对面试保持平常心，该干什么就干什么，不要被面试打乱了正常的学习和生活 面试前不要慌乱，这样反而准备不好 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:4:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"字节跳动 | 今日头条后端开发 | 2022.06.23 ​ 其实去字节面试也不是我主动投的简历，在牛客网上，面试官可能看到了我的简历，然后邀请我投递，我就顺手发了过去，没想到最后还成功拿到面试机会了，这让我很意外，我知道肯定没太大的希望，抱着积累面试经验的态度，我决定去试一下，以下是面试内容。 自我介绍 然后问我实习时间问了好久？ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:0:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"聊天室项目 项目怎么实现的？通过很多个goroutine 用户的消息是怎么转发给其他用户的？通过服务器的广播协程 登录注册怎么实现？ 通过什么登录（电话，邮箱）？ 服务器怎么知道是你（客户端）？网络地址 http长连接还是短连接，请求的全过程（链路） ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:1:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"go语言 GMP模型？ 怎么偷取其他的goroutine？详细说一下？ 垃圾回收机制是怎么实现的？ 乐观锁？ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:2:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"计算机基础 四次挥手 2msl 为什么不是1msl或者3msl？ 数据库 幻读了解吗？ redis几种类型 mysql索引 怎么建立索引？ 三次握手过程 外键需要索引吗 DNS解析的过程？域名服务器怎么解析？ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:3:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"算法题 环链 直接给的main函数，没有其他东西 ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:4:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"心得 面试官问项目问的特别细，所以吸取的教训就是一定要对项目十分熟悉不然就不要写在简历上 大厂不一定需要实习经验，只要对计算机基础和算法掌握的足够深，也可以拿到offer 掌握一些前沿技术（Redis，Docker，K8S）会让自己更有竞争力 之后我也面试官问我还有其他问题吗？我就问了他，对于字节面试需要达到什么标准？对实习经验要求高吗？我还有什么不足的地方？面试官也很热心的回答了我的问题，说他们很重视计算机基础，算法，如果有一些技术特色更占优势比如redis；所以其实字节面试对应届生要求应该不会特别高 这一次只是试一下字节的水，期待自己下次有更好的表现！ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:5:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"目录 上手指南 开发前的配置要求 安装 文件目录说明 使用到的框架 贡献者 如何参与开源项目 版本控制 作者 鸣谢 ","date":"2022-06-24","objectID":"/blog/:1:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"上手指南 ","date":"2022-06-24","objectID":"/blog/:2:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"开发前的配置要求 go1.16以上 ","date":"2022-06-24","objectID":"/blog/:2:1","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"安装 git clone https://github.com/RobKing9/ByteGopher_SimpleDouyin.git ","date":"2022-06-24","objectID":"/blog/:2:2","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"文件目录说明 . |-- Dockerfile |-- README.md |-- controller | |-- comment.go | |-- favorite.go | |-- relation.go | |-- user.go | `-- video.go |-- dao | |-- comment.go | |-- favorite.go | |-- mysql.go | |-- relation.go | |-- user.go | `-- video.go |-- main.go |-- middleware | `-- AuthMiddleware.go |-- model | |-- comment.go | |-- common.go | |-- favorite.go | |-- follow.go | |-- user.go | `-- video.go |-- router | `-- router.go |-- tree.txt `-- utils |-- convertVideoModelListToVideoList.go |-- deleteFile.go |-- format.go |-- jwt.go |-- qiniuUpload.go |-- randNum.go `-- timetool.go ","date":"2022-06-24","objectID":"/blog/:3:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":":yum: 技术栈 Gin Gorm MySQL ","date":"2022-06-24","objectID":"/blog/:4:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"贡献者 请阅读README.md 查阅为该项目做出贡献的开发者。 ","date":"2022-06-24","objectID":"/blog/:5:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"如何参与开源项目 贡献使开源社区成为一个学习、激励和创造的绝佳场所。你所作的任何贡献都是非常感谢的。 Fork the Project Create your Feature Branch (git checkout -b feature/AmazingFeature) Commit your Changes (git commit -m 'Add some AmazingFeature') Push to the Branch (git push origin feature/AmazingFeature) Open a Pull Request ","date":"2022-06-24","objectID":"/blog/:5:1","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"版本控制 该项目使用Git进行版本管理。您可以在repository参看当前可用版本。 ","date":"2022-06-24","objectID":"/blog/:6:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"作者 曾祥文 QQ邮箱：2768817839@qq.com 您也可以在贡献者名单中参看所有参与该项目的开发者。 ","date":"2022-06-24","objectID":"/blog/:7:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"版权说明 该项目签署了MIT 授权许可，详情请参阅 LICENSE.txt ","date":"2022-06-24","objectID":"/blog/:8:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"鸣谢 字节跳动后端青训营 ","date":"2022-06-24","objectID":"/blog/:9:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"}]
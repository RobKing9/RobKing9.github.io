[{"categories":null,"content":"Mac使用指南 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"系统快捷指令 cmd+shift+4截图 Option-Command-Esc强制退出 App Command-M将最前面的窗口最小化至“程序坞”。要最小化最前面的 App 的所有窗口，请按 Option-Command-M。 Command-Tab在打开的 App 中切换到下一个最近使用的 App cmd+Q退出程序(所有窗口)；cmd+W退出该窗口(相当于按到窗口的x) cmd+N新建一个窗口，包括Google浏览器，终端，finder ctrl+cmd+F全屏 Command + H 隐藏(Hide)当前正在运行的应用程序窗口。 Ctrl+cmd+.在finder中输入指令可以显示隐藏的文件 ifconfig | grep \"inet\"查看ip地址，inet的第一个ip就是，不是后面的broadcast ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Item快捷键 在keys中配置ESC ctrl+a移动到行首；+e移动到行尾 ctrl+u删除光标之前的所有字符；+k光标之后的所有 opt+f向后跳一个单词；+b向前跳一个单词 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Google浏览器快捷键 cmd+W关闭当前页面 cmd+↕️箭头是回到顶部和底部 cmd+L光标指向地址栏 ctrl+tab下一个页面；+shift上一个页面 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Typora快捷键 option+cmd+U无序列表，+O是有序；+X任务列表 cmd+数字几级标题 cmd+option+C插入代码块 cmd+F查找；再+option查找替换 cmd+opt+T插入表格 cmd+K插入链接 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Goland快捷键 cmd+R查找替换，+F是查找 cmd+E最近打开的文件 cmd+Shift+U大小写转化 Alt+Shift对比最近修改的代码 cmd+c复制当前行，cmd+D复制行到下一行，cmd+x剪切删除 cmd+展开代码，cmd-折叠代码 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:5:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"VSCode快捷键 cmd+,打开设置 cmd+Shift+F全局文件查找内容，cmd+P查找文件 文件内cmd+F查找，cmd+opt+F查找替换 cmd+Shift+Y打开debug终端，其实就是打开终端，因为终端没有快捷键 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:6:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"网页版飞书快捷键 cmd+Shift+8无序列表 cmd+opt+数字 几级标题 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:7:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"重要程序 ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:8:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Homebrew 安装 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 卸载 $ cd `brew --prefix` $ rm -rf Cellar $ brew prune $ rm `git ls-files` $ rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions $ rm -rf .git $ rm -rf ~/Library/Caches/Homebrew 查看Homebrew版本 brew -v 更新Homebrew brew update 查询可用包 brew search \u003cpackagename\u003e 安装任意包 brew install \u003cpackagename\u003e 比如说可以按照 git，mysql，`` 安装的程序包所在位置 1.配置文件在/usr/local/etc中 2.安装文件在/usr/local/Cellar中 3.二进制可执行程序的软连接在/usr/local/bin中 查找安装软件的路径 brew list \u003cpackagename\u003e 卸载任何包 brew uninstall \u003cpackagename\u003e 查看已安装包列表 brew list 查看任意包信息 brew info \u003cpackagename\u003e 更新go语言版本 /usr/local/等系统目录下的文件读写是需要系统root权限的,导致有些指令需要添加sudo前缀来执行,两种解决方式 对/usr/local 目录下的文件读写进行root用户授权 $ sudo chown -R $USER /usr/local 安装Homebrew时对安装路径进行指定，直接安装在不需要系统root用户授权就可以自由读写的目录下 \u003cinstall path\u003e -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:8:1","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"参考资料 Homebrew介绍和使用 [homebrew安装的文件在哪？怎么查看？已解决] ","date":"2022-09-27","objectID":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:0","tags":null,"title":"Mac使用指南","uri":"/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Docker教程 从配置到部署项目 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:0:0","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"安装与配置 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:1:0","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"Ubuntu环境 ubuntu安装docker教程 拉取镜像太慢，配置镜像加速 vim /etc/docker/daemon.json 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）： {\"registry-mirrors\":[\"https://reg-mirror.qiniu.com/\"]} 可以添加多个 科大镜像：https://docker.mirrors.ustc.edu.cn/ 网易：https://hub-mirror.c.163.com/ 阿里云：https://\u003c你的ID\u003e.mirror.aliyuncs.com 七牛云加速器：https://reg-mirror.qiniu.com 重新启动 $ sudo systemctl daemon-reload $ sudo systemctl restart docker ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:1:1","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"Mac系统 直接使用brew安装cask brew install --cask docker 会下载桌面版本的docker，之后按照提示运行即可 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:1:2","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"初步了解 镜像：类似于虚拟机的镜像，提供执行环境，比如go语言的镜像，就是提供go语言的运行环境 容器：镜像通过执行run方法可以得到一个容器，比如是ubuntu环境，可以在容器里安装RabbitMQ，ES环境。 仓库：拉取镜像的地方 Dockerfile：文本文件（脚本），包含很多执行指令，用于构建自己的镜像，可用于扩展官方镜像。相当于docker image build 的构建镜像的源代码 从仓库（一般为DockerHub）下载（pull）一个镜像，Docker执行run方法得到一个容器，用户在容器里执行各种操作。Docker执行commit方法将一个容器转化为镜像。Docker利用login、push等命令将本地镜像推送（push）到仓库。其他机器或服务器上就可以使用该镜像去生成容器，进而运行相应的应用程序了。 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:2:0","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"常用指令 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:3:0","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"镜像image相关 docker build docker image pull 拉取镜像 docker image ls 正在使用的镜像 (docker images) docker image ls --all 全部镜像 docker rmi \u003cIMAGEID\u003e删除镜像，如果该镜像被容器引用了不能完全删除，需要先删除容器 docker create -it \u003c镜像名\u003e 通过镜像创建container docker run -it \u003c镜像名\u003e 通过镜像创建并运行container -p 8080:8080 -p表示端口映射，格式：宿主机端口：容器运行端口 -e MYSQL_ROOT_PASSWORD=123456 mysql-e表示添加环境变量，这里是mysql的密码。 --name \u003cname\u003e 将容器命名为 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:3:1","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"容器container相关 docker container ls 正在运行的container docker container ls --all 已经使用完的container docker ps查看正在运行的容器 docker ps -a 查看已经退出的容器 docker run -d -it --name centos.7.2 centos:7 -d在后台运行 -it 值得是保持stdout以及分配终端 -i 进入container内部 docker exec -it 容器名称 (或者容器ID) /bin/bash 在宿主机上进入容器，登录守护式容器 docker logs 镜像名 查看日志 docker container kill id 杀死正在使用的container docker start/stop \u003cCONTAINERID\u003e 启动刚create的或者已经停止的container docker (container) rm id 删除使用完的container 防止占用内存 docker network create test-network 容器通信 –network 名字 push到dockerhub docker login登录dockerhub账号 docker push \u003cimageName\u003e ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:3:2","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"Dockerfile ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:3:3","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"拉取MySQL过程 拉取镜像 docker pull mysql docker images查看是否成功 docker run -d \u003c镜像名\u003e -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -v /var/lib/mysql:/var/lib/mysql --name \u003cname\u003e 启动容器 --name mysql 表示将这个容器命名为mysql -v /var/lib/mysql:/var/lib/mysql 表示将宿主机的 /var/lib/mysql 卷映射到容器里的 /var/lib/mysql 卷中，这里是为了我们能够把这个数据保存在宿主机中，防止容器删掉就没了。 -e MYSQL_ROOT_PASSWORD=root 表示MySQL的密码这里设置了root -p 3306:3306 将宿主机的3306端口映射到容器的3306端口 -d 后台运行 mysql:8.0 使用mysql:8.0这个镜像 docker ps查看启动是否成功 docker exec -it robking_mysql\u003c容器名称\u003e /bin/bash 在宿主机上进入容器，登录守护式容器 mysql -u root -p登录mysql 查看mysql版本 -- 第一种 select version(); --第二种 select @@version; 获取docker主机ip，一般应该用第二个吧 docker run --name robking_redis -v /usr/local/redis:/usr/local/redis -p 6379:6379 -d redis:latest ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:4:0","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"Docker部署Gin+MySQL+Redis项目 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:5:0","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"MySQL docker pull mysql拉取mysql镜像 docker run --name mysql -v /var/lib/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql 启动mysql容器，具体使用参考上面 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:5:1","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"Redis docker pull redis拉取redis镜像 docker run --name redis -v /usr/local/redis:/usr/local/redis -p 6379:6379 -d redis 启动redis容器，通过 docker ps查看容器正在运行 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:5:2","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"mall(项目) 制作项目 Dockerfile FROM golang:lasest ENV GO111MODULE=on \\ GOPROXY=https://goproxy.cn,direct WORKDIR /app COPY . . RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-w -s\" -o main RUN mkdir publish \\ \u0026\u0026 cp main publish \\ \u0026\u0026 cp -r conf publish # 指定运行时环境变量 ENV GIN_MODE=release EXPOSE 3000 ENTRYPOINT [\"./main\"] 修改项目的配置文件，这个配置文件里面主要包括 mysql的ip:port; redis的ip:port; mysql连接信息包括账号密码，使用的数据库 docker build -t mall:1.0 .将我们的项目通过Dockerfile制作成镜像 此时会去下载golang环境(镜像)，编译我们的程序，下载相关的依赖，指定暴露的端口 成功的标志是每一步都会返回一串id docker run --name mall -p 3000:3000 -d mall:1.0运行这个镜像 在后面加上 --rm将会在容器结束运行时自动删除 我的理解是相当于我们在本地启动项目 如果启动失败出现数据库连接失败或者忘记建数据库了那么就需要重新删除项目的镜像，改动我们的代码，重新通过Dockerfile制作成镜像，然后重新运行这个镜像(启动项目) ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:5:3","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"Docker-compose进行容器的管理 当我们有多个容器需要启动的时候，我们可以用docker-compose.yml进行容器的管理 此时我们已有的东西是：mysql，redis，mall(项目)三个镜像，但是都没有启动，也就是说此时的mysql没有设置密码，数据库 version: '2' services: civil: build: ./ image: mall:1.0 container_name: robking_mall restart: always environment: MYSQL_DSN: \"root:123456@tcp/test?charset=utf8\u0026parseTime=True\u0026loc=Local\" ports: - 9999:9999 depends_on: - mysql - redis mysql: container_name: robking_mysql image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: test volumes: - /var/lib/mysql:/var/lib/mysql ports: - 3306:3306 redis: container_name: robking_redis image: redis restart: always volumes: - /usr/local/redis:/usr/local/redis ports: - 6379:6379 这个文件其实就是将三个镜像运行成容器的指令用文件的方式进行配置，然后运行起来，项目是依赖mysql和redis，所以会先让这两个先启动，然后再启动项目容器 docker-compose -f docker-compose.yml up -d创建并启动三个容器 ","date":"2022-09-25","objectID":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:5:4","tags":null,"title":"Docker教程 从配置到部署项目","uri":"/docker%E6%95%99%E7%A8%8B-%E4%BB%8E%E9%85%8D%E7%BD%AE%E5%88%B0%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"UBuntu22.04编译内核 | 2022最新 | 详细图解 官网下载内核源码 解压到 /usr/src目录 sudo tar -xavf linux-5.19.8.tar.xz /usr/src 下载安装一系列的软件，为编译内核做准备 sudo apt install libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev bison flex libelf-dev zlibc minizip libidn11-dev libidn11 qttools5-dev liblz4-tool sudo apt-get install libncurses5-dev openssl libssl- dev sudo apt-get install build-essential openssl sudo apt-get install pkg-config sudo apt-get install libc6-dev sudo apt-get install bison sudo apt-get install flex sudo apt-get install libelf-dev sudo apt-get install zlibc minizip sudo apt-get install libidn11-dev libidn11 配置ccache，提高后续编译的速度(可选) sudo apt install ccache sudo gedit ~/.bashrc 在末尾回车，添加如下语句，注意ubuntu要改成你的用户名。 export USE_CCACHE=1 export CCACHE_DIR=\"/home/ubuntu/.ccache\" export CC=\"ccache gcc\" export CXX=\"ccache g++\" export PATH=\"$PATH:/usr/lib/ccache\" 生效 source ~/.bashrc 50G ccache -M 50G 配置以下内容 which ccache # 找到ccache的位置 cd /usr/bin # 我的对应ccache路径 sudo cp ccache /usr/local/bin/ # 建立软链接 sudo ln -s ccache /usr/local/bin/gcc sudo ln -s ccache /usr/local/bin/g++ sudo ln -s ccache /usr/local/bin/cc sudo ln -s ccache /usr/local/bin/c++ ccache -s # 查看当前的一个状况 净化内核源码 sudo make mrproper 将我现有的内核（5.15）版本的config配置信息复制到现在目录下的 .config里面 sudo cp /boot/config-5.15.0.47-generic ./.config 通过make menuconfig 对内核选项进行配置 出现以下界面直接退出ESC然后确定yes即可 编译内核 sudo make bzImage -j8 执行完会在 /arch/x86/boot/目录下生成bzImage文件 出现的问题 Linux内核编译错误：make[1]: *** 没有规则可制作目标“debian(https://so.csdn.net/so/search?q=debian\u0026spm=1001.2101.3001.7020)/canonical-certs.pem”，由“certs/x509_certificate_list” 需求。 停止。** 解决方式 CONFIG_MODULE_SIG_KEY=\"cert/signing_key.pem\" #这个可能不需要删除，删除了反而可能出其他问题make modules_install时报错 CONFIG_SYSTEM_TRUSTED_KEYS=\"debian/canonical-certs.pem\" #这个要删除 实际上应该根据报的具体错删除指定的内容 编译模块 sudo make modules -j8 安装模块 sudo make modules_install 执行本操作 此时/lib/modules/下应该新生成一个新内核版本号的文件. 此时在新内核目录下的操作都已经做完了。编译安装都已经完成，只剩最后的收尾工作。将新内核添加到启动项里面。 将3个文件拷贝到boot目录下 sudo mkinitramfs /lib/modules/5.19.8/ -o /boot/initrd.img-5.19.8-generic sudo cp /usr/src/linux-5.19.8/arch/x86/boot/bzImage /boot/vmlinuz-5.19.8-generic sudo cp /usr/src/linux-5.19.8/System.map /boot/System.map-5.19.8 执行完/boot 目录下 切换到/boot/grub/目录下，自动查找新内核，更新grub 首先进入/boot/grub/ 然后执行update-grub2 这时候你查看一下当前目录下的grub.cfg文件内容。如果发现里面多了新内核的信息。那么恭喜你！ 可以重启进入新内核了。 重启Ubuntu 重启时，长按shift，可进入GRUB，选择Advanced options for ubantu,启动新编译的内核（5.19.8） ","date":"2022-09-13","objectID":"/ubuntu20.04%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/:0:0","tags":null,"title":"UBuntu22.04编译内核 | 2022最新 | 详细图解","uri":"/ubuntu20.04%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/"},{"categories":null,"content":"参考链接 ubuntu(20.04)+linux内核（5.17.3）编译内核 Ubantu20.04更换Linux内核版本（5.8.1） Ubuntu下编译内核 Ubuntu内核编译 ","date":"2022-09-13","objectID":"/ubuntu20.04%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/:1:0","tags":null,"title":"UBuntu22.04编译内核 | 2022最新 | 详细图解","uri":"/ubuntu20.04%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/"},{"categories":null,"content":"百度APP技术部 | Golang后端实习生 | 2022.09.07 ","date":"2022-09-08","objectID":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/:0:0","tags":null,"title":"百度APP技术部 | Golang后端实习生 | 2022.09.07","uri":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"二面面试 时间：2022.09.07 晚上19:00-20:02 时长：1h2min 自我介绍 项目都是自己做的吗？ 介绍一下你最擅长的项目？-分布式对象存储 数据存放在哪里？ES用在哪？ 直接问数据的一致性？ 怎么保证数据的一致性？ 恢复的时候怎么知道谁的数据是正确的？ 如果最后是3对3，怎么少数服从多数？ 如果多个节点垮掉了怎么办？ 怎么进行数据恢复？ MySQL了解吗？参考一下他们的思路实现这个过程？ 有没有运用到实际的场景？ MySQL的存储引擎？除了Innodb和MyISAM还了解其他的存储引擎吗？ 了解索引吗？聚集索引和非聚集索引的区别? 你MySQL运用的场景有哪些？ 建表的mysql语句？ 索引用过吗？ 举了一个联合索引，select * ….. 会不会走索引？ 自己有没有设置表？用户表？有没有设计索引？ varchar了解吗？10的长度可以存20吗？ redis的数据结构？ redis的主从了解吗？ redis的持久化方式？ redis查找aa为前缀的所有数据，怎么查出来？ redis的分布式锁怎么实现？ 其他语言涉及吗？PHP了解吗？ Linux用过吗？说一下哪些指令？ HTTP状态码？502和504什么意思？ go语言的slice和数组有什么区别？slice是有序的吗？ 协程用到异常panic怎么办？怎么捕获，具体的语句怎么写？ 怎么查询go语言的性能？ 两个比较大的数相加怎么做？写代码？ 之后开始让我共享屏幕，打开我的编译器，想了会，面试官提示用什么类型保存？ 你还有什么问题要问？ 面试表现怎么样？有什么改进的地方？基础还不错，代码要结合场景去运用 （面试录了音，所以非常的详细） ","date":"2022-09-08","objectID":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/:1:0","tags":null,"title":"百度APP技术部 | Golang后端实习生 | 2022.09.07","uri":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"百度APP技术部 | Golang后端实习生 | 2022.09.06 ","date":"2022-09-07","objectID":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/:0:0","tags":null,"title":"百度APP技术部 | Golang后端实习生 | 2022.09.06","uri":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"一面面试 时间：2022.09.06 下午14:00-14:51 时长：51min 自我介绍 简单介绍项目 怎么实现接口和数据节点解耦？怎么自由扩展？ 为什么使用消息队列？不使用其他方式？好像也没有太大用处？ 你对RabbitMQ有多少的了解？ 你用到了ES？怎么使用到系统的？ 怎么通过ES得到信息（需要反馈）？结构体信息（元数据） 怎么断点上传？指定range头部 断点上传的过程中有一个数据节点垮掉了怎么办？你会怎么去改进？ 了解其他语言吗？为什么选择go语言？ 有缓存和无缓存的channel有什么区别？关闭的channel（有和无缓冲）可以读到数据吗？确定吗？分别使用什么场景？多个协程访问会怎么样？ 操作系统学过吗？进程，线程，协程的区别？ 进程中一个线程中出现问题会影响到进程吗？ fork一个子进程？父进程垮掉了会影响子进程吗？父进程获取不到子进程的id会怎么样？父进程会等待子进程运行完毕吗 子进程垮掉会影响父进程吗？然后问到了孤儿进程和僵尸进程？ 子进程变成孤儿进程了发生死循环会怎么样？ 进程间怎么通信的？（看了我的博客总结的操作系统网络知识） 计算机网络学过吗？get和put有什么区别？可以改变URL（参数）吗？ TCP和UDP了解吗？ 数据结构学了吗？怎么判断一个链表有没有环？ 怎么判断两个链表有没有公共节点？有没有其他的方法？ 了解排序算法吗？堆排序说一下？大顶堆和小顶堆？堆排序是不是稳定的？其他有哪种稳定的排序？ 归并排序稳定的？为什么会稳定或者会不稳定？ 快排是不是稳定的？算法时间复杂度？最坏是什么情况？时间复杂度？为什么会是O(nlogn)？ 你还有什么问题？ 面试表现怎么样？有什么可以改进的？ 百度技术部用到了哪些技术？用go用的多吗？ 看重哪一方面？容易通过面试 （面试录了音，所以非常的详细） ","date":"2022-09-07","objectID":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/:1:0","tags":null,"title":"百度APP技术部 | Golang后端实习生 | 2022.09.06","uri":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"面试心得 整体面试来说大多数都能回答上来，面试官对于一个知识喜欢一直往下问直到我答不上为止，有一些深度的，还有改进的没有回答上来，面试整体氛围还是不错的，讨论技术有说有笑，另外我发现面试官会去看我的博客以及我写的总结，还有就是竞争者真的很多，面试官也主要是看中了我做的分布式对象存储项目，其他的没做这个项目的都被刷下去了，面试的基本都是做了相关的项目！ 面试体验还不错，我觉得这场面试比之前有很大的提升，同时也学到了很多的东西！ 今晚七点多收到面试通过了，约了第二天的二面！ ","date":"2022-09-07","objectID":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/:2:0","tags":null,"title":"百度APP技术部 | Golang后端实习生 | 2022.09.06","uri":"/%E7%99%BE%E5%BA%A6app%E6%8A%80%E6%9C%AF%E9%83%A8golang%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"Distributed_Object_Storage 项目总结 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"单机版对象存储系统 对象存储是以对象的方式来管理数据的（对象数据+元数据+ID），通过REST网络服务来访问对象。提升了储存系统的扩展性 首先是处理路由，这一章主要是实现了两个REST网络接口： 一个是PUT请求，将数据保存到服务器中，通过 io.Copy()将想要储存的内容复制到文件即可 另一个是GET请求用来下载对象。在服务器中寻找对象，同样通过io.Copy()将服务器该对象的数据写入到HTTP响应体中 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"可扩展的分布式系统 分布式系统的好处在于可扩展性，只需要加入新的节点就可以自由扩展集群的性能。 本章主要是实现了分布式，从整体上来看，就是接口服务节点和数据服务节点 接口服务结点主要的作用是：转发PUT和GET请求到数据服务节点 数据服务节点才是真正处理PUT和GET请求 另外为了验证系统，还加入了locate接口服务，用来定位对象资源。具体实现如下： 首先接口服务收到\"/locate/文件名“的请求，会通过Locate方法获取数据服务的监听地址，先将文件名通过交换机 dataServers 发送到消息队列，数据节点收到之后（Consume）通过Send方法将自身的监听地址发送给自己的消息队列，然后接口服务通过Consume方法收到这个监听地址。 数据服务节点和接口服务节点主要通过消息队列RabbitMQ进行通信，具体使用在于 object包：接口服务节点转发对象 首先是GET请求，先通过locate方法获得对象保存的数据节点位置（监听地址），然后通过Http.Get(url)获得响应即对象内容，此时的URL的服务器是数据服务节点 其次是PUT请求，先随机选择一个数据服务节点（可以通过遍历哈希表找到随机的一个），然后通过Http.NewRequest(\"PUT\", \"URL\", reader)转发该请求，再通过Client.Do(request)获取响应内容（状态码） 数据服务节点的object包和上一章的一样 heartbeat包：数据服务节点每隔五秒发送心跳消息（该节点的监听地址），通过Publish发送到apiServers（交换机）,交换机绑定(Bind)一个消息队列，接口服务节点则通过该消息队列接收数据服务节点的心跳消息，并将监听地址保存到哈希表，每10秒清除没有发送心跳消息的数据服务节点（可能出问题了） locate包：接口服务节点通过Publish将定位消息（对象）发送到dataServers（交换机），同样绑定一个消息队列，数据服务节点收到定位消息，会在服务器寻找该对象是否存在，发送反馈消息(Send)，存在就会发送该对象保存在哪一个数据节点（监听地址）。 另外是测试的环境 通过在一台虚拟机绑定多个IP地址实现多个节点。 安装RabbitMQ-server，创建两个交换机 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"元数据服务 这一章主要是为了记录对象的不同版本。元数据指的是对象的描述信息，比如说名字，版本，大小以及散列值。 我们用Elasticsearch来实现元数据服务，它的索引相当于数据库，类型相当于表，属性相当于列。 与上一章相比，我们的代码主要新增了es包，utils包。 es包：封装元数据服务的一些API，包括查看最新版本，查看一个对象的所有版本，增加一个版本，获取一个版本。因为Elasticsearch也相当于一个服务器，对于不同的索引保存的信息在服务器中，可以类比成MySQL保存数据 utils包：只要两个函数，一个是获取请求头部的散列值，一个是获取请求头部的长度信息。 主要新增了version接口用来查看对象的版本，新增delete实现对对象的删除。 下面来说一下对象的put和get实现细节 put请求：我们可以从请求头部获取它的散列值，长度，名字，这样我们就可以调用es包下的API来添加一个版本。另外我们发送PUT请求的时候需要带上它的散列值。 get请求：与上一章不同的是，我们是将对象的散列值作为全局唯一变量。首先我们很容易获取请求的名字和版本号，根据这两个信息，他们调用es包下的API来查找它的元数据，这样我们就可以获取它的散列值，用这个散列值替代上一章的名字去访问 delete请求：用于删除一个版本，首先我们通过名字获取它的最新版本，然后增加一个版本，只不过这个版本的长度为0，散列值为空，用来表示这是一个删除标记，实际上是没有删除，我们依然可以通过/version接口查看之前的版本。 另外数据服务存储的不再是对象的名字，而是散列值，这个散列值就是从请求头部获得的。 因为散列值是根据对象内容来计算出来的，所以不同的版本有不同的散列值，以不同的文件存放在服务器中。 想想还觉得非常不合理，哪个傻逼会存放东西的时候，还要根据内容计算出一个散列值，然后再去存呢？ ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"数据校验和去重 这一章主要是进行数据校验和去重。这是非常重要的，如果一份数据保存几百份甚至更多会占用我们的空间，这就是去重，数据校验是为了防止恶意客户端错误的信息去请求，我们当然要拒绝，另外也是为了防止数据在传输中发生的错误。 首先是去重，其实实现起来不是很复杂，数据服务启动的时候先将磁盘扫描一遍，将所有的文件名（散列值）缓存下来，以防止定位服务多次访问磁盘，这样可以直接访问内存，提高了速度；之后客户端请求一个数据的时候我们就会去这个缓存中寻找，如果有的话就直接添加一个版本就好了。当然这样做也是有很大的局限性，PUT一个对象会等待1秒，这是去重导致的性能问题。 另外就是数据校验的实现，这一个相对来说复杂一点，当用户PUT一个对象的时候，我们需要根据请求对象的内容来计算出一个散列值，然后和传入的散列值进行比对，成功才会上传这个对象，否则就会删除。这样也会导致一个问题，需要校验的话我们要等待对象上传完之后才能计算出散列值，但是如果对象太大的话，可能超出接口服务的内存。 我们的解决方法是给数据服务增加缓存功能，这样一来接口服务的PUT方法就被新增的POST，PATCH，PUT，DELETE四种方法替代了。下面我们详细说明这个缓存的临时接口 /temp POST方法：一开始执行POST请求增加一个对象，此时请求的是散列值，响应uuid；这里的uuid是服务器随机生成的，具体生成方式我有点疑惑。这个uuid是临时对象的标识，除此外还会新建两个文件，这两个文件都是以临时对象标识uuid进行命名的，一个文件记录数据的信息，包括散列值，uuid，size，另一个文件是数据文件，此时只是做好准备，没有数据，之后会通过patch方法打补丁，将数据写入。 /temp PATCH方法：通过PATCH方法将请求的内容写入到数据文件，这时候请求的是通过POST方法获得的uuid（临时对象标识）。具体实现是，根据uuid读取信息文件，找到并打开数据文件，将请求体内容保存到数据文件，这是哈还需要比较数据文件的size和信息文件的size字段，我不太明白这是为什么？难道还会不相等吗？ /temp PUT方法：用来更新一个对象，将之前的临时文件转正，首先会通过uuid读取信息文件，还是一样获取到的size比较？删除信息文件，更改数据文件的位置（转正），在缓存中增加自己的文件名。 /temp DELETE方法：用来删除一个对象，通过uuid删除信息文件和数据文件。 另外接口服务的GET方法有所改变，获取一个对象的时候我们也需要进行数据校验，主要是为了防止存储系统的数据降解导致数据随着时间的流逝而逐渐损坏。具体是这样实现的：根据传入的哈希值找到文件，根据文件内容计算散列值，与传入的散列值校对，成功的话返回文件名，根据文件名将文件内容写入到响应体中。 以上就是数据服务的变化，下面是接口服务的变化 GET方法没有变化，主要变化是PUT方法 去重和PUT一个对象进行的数据校验都是在数据节点完成。当没有找到文件的时候就需要新增一个对象，首先会发送POST请求，此时会让数据服务建立信息文件和数据文件以就绪，请求获得uuid，然后根据这个uuid需要发送PATCH请求，将请求体内容写入到数据服务的临时数据文件中，然后通过io.TeeReader将请求体和uuid，server写入reader，通过这些内容计算出散列值，然后进行校对，这里我也有点不明白，这样怎么可能散列值会相等？之后比对成功就会发送PUT请求将对象转正，否则删除文件。 以上就是这一章所有的去重和数据服务的实现，但是我们会有一个问题，所有的文件都只有一份，对于保护用户数据来说是十分危险的，所以下一章我们会通过数据冗余来解决这个问题！ ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:4:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"数据冗余和修复 上一章我们留下了一个数据丢失如何解决的问题，这一章我们主要就是实现数据冗余与修复，抵御数据丢失，我们利用的事RS码的4+2的数据冗余策略，接下来是具体PUT一个对象和GET一个对象的细节实现。 先提前对一些知识进行说明，RS码是将一个对象的内容分成4个分片，每个分片都有一个id，另外2个是修复分片，以防数据节点出问题，用来修复分片数据。 首先需要PUT一个对象。请求传入的是对象的名字以及hash。 流程是这样的 宏观上的函数调用过程 StoreObject——\u003eputStream——\u003eNewRSStream——\u003eNewTempPutStream 我们可以从一步一步看，putStream流主要是获得六个数据服务的节点，然后通过NewRSStream流发送六个请求，这个时候的hash是hash.id，最后是调用NewTempPutStream发送post请求到数据服务，这时候会建立6个信息文件和6个数据文件。此外post请求也会响应servers和uuids，这个会通过writer流写入RSStream进行编码。这样一来在StoreObject中有一个io.TeeReader会将请求体写入到stream中，而这个stream就是RSStream，也就是会调用write方法，通过循环每一次写入32000字节的文件到缓冲中，当缓冲满了之后会调用flush方法，这个方法会对数据内容进行拆分，并且实现奇偶校验，接着遍历将六个分片分别调用tempstream的write方法，发送patch请求，写入到数据文件中。最后验证散列值，成功的话就将其转正，本质上是发送put请求，这个时候数据服务会通过uuid找到信息文件，信息文件保存了每个分片的name（hash.id）和size，然后找到数据文件，根据内容可以计算出这个分片的hash值，最后将这个临时对象重新命名变成 hash.id.\u003cshard of hash\u003e 数据服务 一个变化就是对接口服务的定位信息的反馈，之前只是反馈一个节点地址，但是现在需要反馈所有节点监听地址及相应的分片id，我们用一个结构体来将这些数据反馈给接口服务。 每个分片存储的文件格式为hash.id.\u003cshard of hash\u003e, 所以我们缓存的节点监听地址也有变化，值变成了对应的分片id，还是一样从所有文件进行寻找，将分片id和监听地址一一对应。 最后一个变化就是将对象转正的时候，因为我们存储的格式变化，我们需要根据每个分片内容计算它的散列值，然后进行转正重命名，将其加入到缓存中。 接口服务 locate方法发生了改变，需要接收到六个分片id以及对应的监听地址。 之前是随机选择一个数据节点，现在变成了选择六个数据节点，因为每个节点都需要存放分片数据，通过storeObject函数转发post请求，这时候有六个数据节点，每个节点都需要返送post请求，响应返回uuid，server；这些数据都会存放在写入流中，函数返回的是stream，这其中包括这个写入流，通过io.TeeReader(r, stream) 将内容输出到reader中，计算散列值，进行比对，然后转正。 其次是GET一个对象。请求体是对象的名字和版本号。 流程是这样的 整体上来看函数的调用过程 get——\u003egetStream——\u003eRSGetStream——\u003eNewGetStream(NewTempStream) 还是一步一步往后看，首先根据请求的名字和版本号通过元数据服务可以获得hash值，然后发送定位消息，这时候会出现两种情况，一种是返回了六个节点的地址，另一种情况是有一个或者两个数据节点的内容损坏了，这时候我们需要对其进行修复，通过随机获得数据节点那个函数，可以获得出错的数据节点地址，接着RSGetStream会发送get请求，如果数据节点没有问题的话，就可以通过reader读取到数据，但是如果有问题那么读取到的内容为空，这时候出现了两种情况，所以针对读取到内容为空的数据节点进行修复，通过NewTempStream重新上传数据，和之前的put一个对象一样，会有一个writer，这样整个流程走完了，执行到了get函数的io.Copy(w, stream)，此时会将stream流获得的数据写入到响应体中，这时候调用RSGetStream实现的read方法，这个方法具体是先看一下缓存中有没有数据，没有的话就会从之前获得数据的reader中取出来，因为有几个为空，我们可以吧id拿出来，然后通过writer把这些数据写入到服务器中，这样一来读取的所有数据就会到响应体中。 接口服务 根据请求体获取元数据，从而获得hash；然后通过hash和size定位到每个分片的id和serve（来自数据服务的反馈信息）；如果我们获取到的server不足六个，你们说明有的数据节点数据出现了问题，所以我们需要进行修复，通过选择节点的那个函数修复，下面详细说明 ChooserRandomDataServers这个函数主要是传入需要的节点数量以及已经有的server，然后获得所有数据节点中不包括这些有了的server。 以这种方式获取到的server数据一般都没有，所以需要进行修复，重新发送post请求，修复数据，这些数据在写入流中，而之前存在的数据发送get请求获得每个分片的数据文件内容，会放在reader中，所以数据要么在writer中要么在reader中 调用io.Copy()方法，将读取到的内容写入到响应体中，内容实现Read方法。 数据服务：主要是主要GET请求中的“hash.x”, 从所有文件中匹配这样一个文件，只有唯一一个，通过文件内容计算出它的散列值与实际保存的文件名上的散列值作比较，最终将内容写入到响应体中即可 这样实现是比较复杂的，但是提高了整个存储系统的负载均衡。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:5:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"断点续传 这一章主要是解决了由于网络问题导致下载和上传阻断的问题，我们让用户可以从断点开始上传或者下载。 首先是断点上传，因为我们在接收一个对象需要对其进行hash验证，所以我们必须使用特定的接口上传。我们采用post接口，当用户知道自己上传的是很大的对象的时候，应该主动用这个接口进行上传 下面详细说明断点上传一个对象的流程 前面和put请求实现类似，判断hash是否存在，如果已经存在不进行后序操作，否则调用NewRSResumablePutStream方法，这个方法主要是调用NewRSPutStream方法，这其中和上一章一样，每个分片发送post请求，获得putStream流，接着通过putStream.Writers[i].(*objects.TempPutStream).Uuid接口回调获得所有的uuid数据，这样再保存到我们的token中，token的数据包括name，size，hash，servers，uuids，这样一来我们直接响应，只不过内容是token，当然这个token是将这些数据进行编码得到的，解码可以得到其中的数据流。 然后客户端自主改用post方法，temp/token接口，实现对对象的上传，首先对请求体的token进行解码得到数据流，因为我们实现的是断点上传，所以我们需要知道当前已经上传了多少对象了，用current标识，具体实现如下 通过发送 head请求可以获得一个分片的数据文件的大小，乘以4就可以得到已经上传对象的大小了 这个head请求数据服务实现的，主要是通过传入的uuid获取数据文件，然后就可以得到其中一个分片数据文件的大小响应头部给接口服务。 然后请求内容也需要提供一个断点，我们会比较这两个值，肯定是会相等的，除非客户端传错了。然后我们会循环每次写32000字节的文件到缓存中，然后调用stream的write方法将内容上传到服务器中，这时候还没有转正，因为还没有校验，当所有的内容上传完毕的时候，我们会通过调用NewRSResumableGetStream方法，这个方法之后通过发送get请求（这个get请求时temp下的）获得所有的数据，通过这个我们就可以计算出真正的hash值，与传入的进行比较，相同的话将文件转正即可。 下面是断点下载对象的流程。 断点下载还是比较简单的，只要跳过已经下载的字节就可以了，前面的基本是一样的，唯一不同的是需要从请求中获取偏移量offset，然后通过这个offset我们就去跳过，调用Seek函数， 这个函数是核心，以下是具体实现 我们会去循环的跳过，每一次跳过32000，通过io.ReadFull(s, buf)，这个是核心，s是stream流，这里作为io.Reader接口主要是获取reader中的内容，由上一章我们可以知道，这个reader就是数据文件的内容读取流，我们把他转移到buf中，知道偏移量为0，这时候reader中的内容就会减少offset个字节。 最后我们再调用io.Copy(w, stream)，此时同样是从stream中的reader读取流中写入到响应，由于之前已经跳过了，所以这时候开始的地方就是我们需要的数据。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:6:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"数据压缩 为了提高传输速度和节省网络带宽，我们对数据进行压缩，使用的事gzip算法。 gzip主要有两个API，一个是NewWriter，创建一个writer对象，用来写入压缩的数据 w := gzip.NewWriter(f) //f是一个io.writer接口 可以是一个文件 io.Copy(w, oldf) //将之前文件的内容写入到w中，主要w进行压缩再将压缩后的内容写入到f中 gzipStream, err := gizp.NewReader(f) //可以将压缩文件内容直接以流的形式 写入到响应体中 io.Copy(w, gzipStream) 具体有以下几个地方需要进行压缩。 首先是put一个对象转正的时候，之前我们是重命名，这时候我们可以对数据进行压缩，然后存储，可以节省存储空间 然后就是数据服务响应文件内容的时候，直接使用gzip.NewReader，将压缩文件写入到响应体中。 最后就是客户端GET一个对象的时候，可以设置头部Accept-Encoding为true，这样就可以接受压缩文件了，接受过程和第一点相似，通过gzip.NewWriter。 整体来说本章不算很复杂，这样一来我们就节省网络带宽，节省存储 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:7:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"数据维护 这一章主要是对数据进行维护。 删除过期的元数据，将保留过久的版本删除，保留最近的五个版本 删除没有元数据引用的对象数据 对象数据的检查和修复 项目完整总结 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:8:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"这个项目是如何设计与实现的？ 一开始我们只是一个单体服务，客户端发送put请求存储数据，我们就将其存到磁盘中，客户端发送get请求下载数据，我们从磁盘中读取出来给客户端。但是这样我们存在一个问题，当客户端请求骤增，服务器磁盘IO负载过高时，都会导致性能下降，并且不好扩展。 针对上面的问题，我们将接口服务和数据服务解耦，接口服务只负责接受客户端请求，数据服务只用来请求磁盘，这样一来我们就可以轻松地往集群中扩展新的接口服务节点和数据服务节点，而接口服务和数据服务之间通过消息队列RabbitMQ进行信息的传递。但是我们也存在了一个问题，当客户端多次put同一个对象的时候，我们在数据服务节点都会存在很多同样的数据，这样非常浪费存储空间，对此我们需要解决数据去重这个问题；但是如果我们put同一对象，而每次数据都不一样，这时候我们可以保存对象的多个版本，对数据进项版本控制。 我使用的是ElasticSearch进行版本控制，它类似于数据库，索引相当于数据库，类型相当于表，每一个属性相当于列。利用ES客户端可以找到指定版本的数据，可以查询所有的版本，ES会保存对象的元数据，包括名字，大小，散列值，这个散列值是客户端通过Sha-256计算出来的，当客户端put一个对象的时候，首先还是会保存在数据服务中，然后会在ES服务器中添加一个版本的元数据，每次版本号加一，当get一个对象的时候，还是一样请求ES服务器返回对应的元数据信息，之后再去请求数据服务返回相应的数据。 另外一个就是数据去重的问题我们需要解决。同时因为客户端数据在传输中可能出现数据丢失问题，或者有一些恶意的客户端发送不一致的信息，这时候服务器不能将这些错误的信息保存下来，还有一种情况是服务器因为数据放久了出现数据降解的问题，这时候都需要对数据进行验证，保证接收和发送的数据完整性。解决去重问题，我们可以在接口服务节点转发请求之前，先发送定位信息，通过交换机发送对象数据散列值的信息，数据服务节点会搜索本地磁盘是否存在这个对象，存在的话就会反馈保存的数据节点的监听地址，否则什么也不返回。对数据进行校验我们就需要通过对象的内容计算出散列值，然后和客户端传进来的散列值进行比较，如果不同则拒绝服务，因为我们要接受完数据才能进行计算校验，但是如果文件内容比较大的话，很有可能会超出接口服务节点的内存，所以我们需要将数据转移到数据服务保存到一个临时的地方，当数据校验通过的话，将文件存储到正确的地方，还有就是客户端下载一个对象，我们也需要对取出来的对象进行数据检验。因为有数据降解问题的存在，我们又会想到一个新的问题，如果服务器上一个数据丢失了怎么办？客户端就拿不到数据了 对于这个问题，一种方法是保存多份，还有另一种方法就是将一个对象分成很多分片，然后每个分片保存在不同的数据服务节点，我使用的是RS纠删码来设计的，其中有我们将对象分成四个数据分片和两个校验分片，大小都是对象的25%，我们将每个分片保存在六个数据服务节点中，只有其中四个我们就可以还原完整对象，所以我们可以允许两个节点数据出错，这时候用户put一个对象的时候，我们就需要选择六个数据节点，每一个节点进行上面的post，patch，put操作。另外就是如果某个数据节点的数据出现了问题我们还需要对其进行数据修复，当客户端get一个对象的时候，接口服务可以通过心跳机制获得所有数据节点的监听地址，但是如果某个出问题了，我们就可能只能收到其中的五个，那么就需要对另一个数据进行修复，根据RS的原理我们可以很容易进行修复。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:9:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"消息队列是如何设计的？接口节点和数据节点如何交换信息的？ 首先数据服务得知道有哪些可用的数据服务节点可以请求，那么数据节点就要发送信息给数据节点，这个过程叫做心跳机制，接口服务节点会绑定一个接口交换机，数据服务每隔五秒给接口服务发送自己的监听地址，接口服务会将这些监听地址按照时间保存到内存中，并且会清除10s没有发送心跳信息的数据节点，因为可能出问题了。这样接口服务转发请求的时候就可以直接选择一个数据节点发送请求 另外接口服务节点还会给数据服务节点发送数据的定位消息，以确定数据在磁盘中的具体情况。这个时候数据服务节点也会绑定一个数据交换机，当数据服务节点收到定位信息的时候，就会反馈这个数据保存在的数据节点地址。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:10:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"心跳机制是如何设计的 数据服务会启动一个协程每隔五秒 通过数据服务绑定的交换机给接口服务发送自己的监听地址，接口服务收到之后会保存收到的时间以及节点地址到哈希表中，每次保存的时候都需要上锁，保证数据的正确性；并且会清除10s仍没有发送心跳信息的数据节点，因为这些节点肯定是出现问题了，同样接口服务也是开辟的一个协程来处理心跳信息。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:11:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"怎么进行版本控制的？ 我是通过Elasticsearch实现的，当客户端发送put请求的时候，我们会根据元数据想ES服务器发送put请求保存这个版本，并且每次版本号加一，当客户端需要获取一个版本的元数据信息，直接发送get请求到ES服务器，接着ES服务器会响应对应的元数据信息，如果客户端想知道所有的版本信息，接口服务会请求ES服务器查询所有的版本，并且我们可以让它进行版本号降序排列，这样有时候客户端不指定版本号，我们就可以返回最新的版本信息。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:12:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"怎么对数据进行校验和去重的？ 首先是去重，去重意味着如果客户端上传了一个内容相同的对象我们就拒绝保存，客户端put一个对象的时候，接口服务通过消息队列向数据服务节点发送定位消息，数据服务节点会在磁盘中寻找，当然为了提高查找速度，数据服务节点在启动的时候会通过一个协程，将所有的文件名即对象的散列值保存到哈希表中，这样接口服务节点请求定位信息的时候，数据服务节点直接在哈希表中查找是否存在，通过消息队列反馈给接口服务。如果不存在的话才会继续去请求保存。 其次是数据校验，当客户端发送put请求的时候，我们需要通过对象的内容计算出散列值，然后和客户端传进来的散列值进行比较，如果不同则拒绝服务，因为我们要接受完数据才能进行计算校验，但是如果文件内容比较大的话，很有可能会超出接口服务节点的内存，所以我们需要将数据转移到数据服务保存到一个临时的地方，具体我们可以让接口服务节点发送post请求，让数据服务提前做好准备，新建一个信息文件包括对象的散列值和大小，以及一个用来存储数据的文件，当然这时候还是空的，返回给接口服务节点uuid，接着接口服务节点通过uuid发送patch请求，将客户端请求的数据保存到数据服务的临时数据文件中；当所有内容已经保存到临时数据文件的时候，这时候接口服务也通过内容将散列值结算出来了，如果和客户端传进来的散列值相同的话，意味着数据校验通过，紧接着接口服务发送put请求，数据服务节点将文件转正，存储到正确的地方，但是如果没有通过校验的话，接口服务会通过delete请求，数据服务将会删除临时的信息文件和数据文件。还有就是客户端下载一个对象，我们也需要对取出来的对象进行数据检验。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:13:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"怎么对数据进行存储和修复的？ 对于这个问题，一种方法是保存多份，还有另一种方法就是将一个对象分成很多分片，然后每个分片保存在不同的数据服务节点，我使用的是RS纠删码来设计的，其中有我们将对象分成四个数据分片和两个校验分片，大小都是对象的25%，我们将每个分片保存在六个数据服务节点中，只有其中四个我们就可以还原完整对象，所以我们可以允许两个节点数据出错，这时候用户put一个对象的时候，我们就需要选择六个数据节点，每一个节点进行上面的post，patch，put操作。另外就是如果某个数据节点的数据出现了问题我们还需要对其进行数据修复，当客户端get一个对象的时候，接口服务可以通过心跳机制获得所有数据节点的监听地址，但是如果某个出问题了，我们就可能只能收到其中的五个，那么就需要对另一个数据进行修复，根据RS的校验片我们可以很容易进行修复。 ","date":"2022-08-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/:14:0","tags":null,"title":"分布式对象存储系统项目总结","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Git的安装和配置 下载Git 配置环境变量 检验安装成功 配置全局信息 git config --global user.name \"RobKing\" //用户名 git config --global user.email \"2768817839@qq.com\" //邮箱 git config -l //查看全局信息 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"配置代理 git config --global https.proxy http://127.0.0.1:7890 //配置代理 git config --global --unset http.proxy //取消http代理 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:1","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Git指令的使用 git log查看commit日志 git log --oneline --graph --decorate --all查看节点树 git reset --hard commit_id 回退到指定id （指定版本） ​ 此操作结束之后 本地代码和远程仓库代码 都会回退到 原来的版本 git reset --hard origin/dev 取消当前改动(回退指定id的改动），重置到库的最新版本（取消回退） ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:2:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"将项目上传到Github上 进入Github首页，点击New repository新建一个项目（添加一个Readme） 在项目的根路径下git clone + 项目名（下载指定分支 git clone -b dev ***） 更新代码提交 git add . git commit -m \"first commit\" git push origin master(main) ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:3:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"本地项目与Github同步 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"添加SSH KEY ssh-keygen -t rsa -C “2768817839@qq.com” 成功生成SSH key了，可以到C:/Users/你的用户账号/.ssh文件夹下看 Linux下可以cd ~./ssh 复制.ssh文件夹下id_rsa.pub文件的内容添加到github 测试ssh连接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:1","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"关联本地库和远程库 git remote add origin git@github.com:RobKing9/CargoManageSystem.git 如果ssh被占用 将导致或者如果项目是http协议 需要删除远程git仓库，执行git remote rm origin 执行指令 git remote -v查看当前情况 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:2","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"拉取最新代码 参看版本差异可直接 git log -p master ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:4:3","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"Git分支管理 将远程仓库的分支信息拉取到本地仓库git fetch 在本地创建新分支 git branch [分支名] 切换分支 git checkout [分支名] git branch 查看本地分支 git branch -a 查看所有分支 git checkout -b main origin/main 创建并切换分支 删除分支 本地：git branch -d master 远程库：git push -d origin master或者git push origin :master ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:5:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":".gitignore文件的使用 如果项目已经push上去了 但是没有忽略 ，增加 .gitignore 文件 .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: git rm -r --cached . 再次执行 git add . --\u003egit commit -m \"update .gitignore\" --\u003e git push origin dev *.a 表示忽略所有 .a 结尾的文件 !lib.a 表示但lib.a除外 /TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹； .idea/ doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 表示忽略根目录下的bin文件 /*.c: 表示忽略cat.c，不忽略 build/cat.c debug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj **/foo: 表示忽略/foo,a/foo,a/b/foo等 a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等 !/bin/run.sh 表示不忽略bin目录下的run.sh文件 *.log: 表示忽略所有 .log 文件 config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹 *.zip 表示过滤所有.zip文件 /mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下： !*.zip !/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？ 想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：： /mtk/* !/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！ 注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ---------------------------------------------------------------------------------- 还有一些规则如下： fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； /* !.gitignore !/fw/ /fw/* !/fw/bin/ !/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:6:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"git commit message 编写指南 Head+Body+Footer ；Head: type • feat：新功能（feature） • fix：修补bug • docs：文档（documentation） • style： 格式（不影响代码运行的变动） • refactor：重构（即不是新增功能，也不是修改bug的代码变动） • test：增加测试 • chore：构建过程或辅助工具的变动 scope subject ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:7:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"使用tree命令生成项目目录树 下载 tree 命令的二进制包，安装 tree 命令工具;地址，选择下载 Binaries zip 文件 解压压缩包，找到压缩包内的 bin 目录，将 bin 目录下的 tree.exe 复制； 找到Git的Bin目录，将 tree.exe 粘贴到该目录下，安装即完成 tree -L 5 -I \"node_modules|dist|dist.zip\" \u003etree.txt 将目录结构导出 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:8:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"使用Git遇到的Bug及解决方法 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:0","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"解决git clone速度慢的方法 //这是我们要clone的 git clone https://github.com/Hackergeek/architecture-samples //使用镜像 git clone https://github.com.cnpmjs.org/Hackergeek/architecture-samples //或者使用镜像 git clone https://git.sdut.me/Hackergeek/architecture-samples 几个可用的镜像源 https://hub.fastgit.org](https://hub.fastgit.org/) https://github.com.cnpmjs.org](https://github.com.cnpmjs.org/) https://github.bajins.com](https://github.bajins.com/) https://github.rc1844.workers.dev](https://github.rc1844.workers.dev/) ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:1","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"合并代码遇到error: Your local changes to the following files would be overwritten by merge 解决方法 执行git stash 本地刚才修改的代码将会被暂时封存起来 git merge origin/feature-feed-user 重新合并 git stash pop 服务器上的代码更新到了本地，而且你本地修改的代码也没有被覆盖 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:2","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"提交代码遇到To github.com:RobKing9/ByteGopher_SimpleDouyin.git ! [rejected] dev -\u003e dev (non-fast-forward) error: failed to push some refs to ‘github.com:RobKing9/ByteGopher_SimpleDouyin.git’ 解决方法 说明远程仓库的代码比本地先更新 遇到了冲突 无法提交 首先把远程仓库最新的代码拉下来 （参考上面 本地项目与Github同步的拉取代码） 手动解决冲突 留下需要的代码 删除不需要的 再次执行 git add . --\u003egit commit -m \"\" --\u003e git push origin dev ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:3","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"git-修改commit信息 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:4","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"添加远程仓库遇到fatal: unsafe repository (‘D:/AGolang/src/Aproject/ByteGopher_SimpleDouyin’ is owned by someone else) 解决方法 git config --global --add safe.directory * 参考链接 ","date":"2022-07-25","objectID":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:9:5","tags":null,"title":"Git使用指南","uri":"/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"操作系统面试总结 | 2022最新 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"github链接欢迎star！ ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"我的博客 进程，线程，协程 简述线程和进程的区别和联系 进程的状态与状态转换 什么是孤儿进程？僵尸进程? 并发和并行有什么区别？ 什么是内核态和用户态？如何实现两者之间的相互转换？ 锁，同步，通信 什么是死锁？死锁产生的必要条件？ 如何解决死锁问题？ 你了解乐观锁和悲观锁吗？ 进程间通信的方式有哪些？ 线程同步有哪些方式？ 存储管理 了解虚拟内存吗？ 什么是分页？什么是分段？两者有什么区别？ 软链接和硬链接有什么区别？ 页面置换算法有哪些 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"进程，线程，协程 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"简述线程和进程，协程的区别和联系 区别 进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。 一个进程可以有多个线程，但是一个线程只能属于一个进程。一个线程可以有多个协程，一个进程也可以有多个协程。 进程的创建需要系统分配内存和CPU等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。 进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。 线程和进程都是同步机制，而协程是异步机制。 协程不被操作系统内核管理，而完全是由程序控制。协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。 联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。一个线程可以有多个协程，一个进程也可以有多个协程。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:1","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"进程的状态与状态转换 进程在运行时有三种基本状态：就绪态、运行态和阻塞态。 执行：进程分到CPU时间片，可以执行 就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行 阻塞：有IO事件或者等待其他资源 各状态之间的转换： 就绪→执行 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。 执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 执行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。 阻塞→就绪 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:2","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是孤儿进程？僵尸进程? 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。 僵尸进程： 进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:3","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"并发和并行有什么区别？ 并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。 并行就是在同一时刻，有多个任务在执行。这个是物理上的多个进程同时进行。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:4","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是内核态和用户态？如何实现两者之间的相互转换？ 为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。 内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。 用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。 用户程序运行在用户态,操作系统内核运行在内核态。 处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。 异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。 外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:5","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"锁，同步，通信 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是死锁？死锁产生的必要条件？ 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。产生死锁需要满足下面四个条件： 互斥：一个资源一次只能被一个进程使用； 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源； 非抢占条件：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放； 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:1","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"如何解决死锁问题？ 解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下: 资源一次性分配，这样就不会再有请求了（破坏请求条件）。 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。 可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:2","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"你了解乐观锁和悲观锁吗？ 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。适用于多读场景。 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。适用于多写的场景。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:3","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"进程间通信的方式有哪些？ 管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 消息队列：消息队列是消息的链表，存放在内核中并由消息队列标识符标识 信号(Signal)：信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。 共享内存：共享内存是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。共享内存是最快的IPC方式 信号量(Semaphore)：信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。 套接字(Socket)：套接口也是一种进程间通信机制，它可用于不同主机间的进程通信 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:4","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"线程同步有哪些方式？ 信号量：允许统一时刻多个线程访问同一个资源，但需要控制统一时刻访问此资源的最大线程数量 互斥量：实际上是信号量的一种特殊情况，允许统一时刻只有一个线程访问同一个资源 信号，也叫事件：通过通知操作的方式来保证多线程同步，还可以方便实现多线程优先级的比较操作 多线程锁实现多线程同步 互斥锁：保护临界区，确保同一时间，只有一个线程访问数据。如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁 自旋锁：在获取到锁之前，一直处于循环检测保持者是否已经释放了锁。与互斥锁的区别是，在申请自旋锁时，线程处于忙等状态，而非挂起状态 信号量：一个计数器，用来控制多个进程对共享资源的访问。互斥锁为信号量的一个特殊情况。 读写锁：高级别锁，区分读和写，符合条件时，允许多个线程访问对象。处于读锁时，允许其他线程和本线程的读锁，但不允许写锁。处于写锁时，任何锁操作都会睡眠等待 递归锁：递归锁是互斥锁的一个特殊情况。同样地，只能由一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时，反复对锁进行加锁操作 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:5","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"内存管理 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"了解虚拟内存吗？ 每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页；但不需要所有的页都在物理内存中，当程序访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:1","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"什么是分页？什么是分段？两者有什么区别？ 页式存储：把内存空间划分为大小相等且固定的块，因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻； 段页式存储：用户进程先按段划分，段内再按页划分，内存 划分和分配 按页。 分页主要用于提高内存利用率，实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:2","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"软链接和硬链接有什么区别？ 软链接可以理解为 Windows 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径。 硬链接就是记录着文件名和源文件的inode编号。 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:3","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"页面置换算法有哪些 在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断，将磁盘中该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下： 先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。性能较差，调出的页面可能是经常访问的 LRU算法：置换最近一段时间以来最长时间未访问过的页面。 LFU算法：缺页时，置换访问次数最少的页面 ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:4","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"参考资料 操作系统八股文背诵版 操作系统常见面试题（2021最新版） 操作系统最强面经面试题总结 | 春招秋招必备 | Offer收割 超全面的后端开发C/C++面经整理分享含详细参考答案 包括简历分享 JobInterviewGuide/interview_guide ","date":"2022-07-15","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:6:0","tags":null,"title":"操作系统面试总结\t | 2022最新 ","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"计算机网络 github地址 HTTP，HTTPS，DNS协议 OSI七层模型 介绍一下OSI七层模型和TCP五层模型？ TCP,UDP,IP协议分别属于什么层？ HTTP版本1.0,1.1,2.0 http/1.0和http/1.1有什么区别？ http短连接和长连接有什么区别？ http/2.0相比较与http/1.1有什么特性？ HTTP报文结构，请求方法，状态码 http请求方法有哪些？ get和post方法有什么区别？ http状态码200,403等等表示什么意思？ HTTP和HTTPS HTTP和HTTPS的区别？ 请简述TLS技术的工作原理？ DNS服务与安全 请简述域名系统DNS的工作流程？ 你了解DNS攻击吗？是什么原理？ TCP，UDP，IP协议 传输层协议 请简述TCP和UDP的区别？ TCP连接及释放 请简述三次握手的过程？为什么两次不行？ TCP三次握手时的第一次的seq序号是怎样产生的字节提前批 请简述四次挥手的过程？为什么三次不行？ TIME_WAIT为什么是2MSL，而不是1MSL或者3MSL？ TCP的可靠连接和粘包 请简述TCP协议的滑动窗口？ 请简述TCP协议的拥塞控制及算法？ 拥塞控制和流量控制的区别 请介绍一下TCP的粘包现象以及如何避免 请简述SYNflood攻击的原理 浏览器中输入一个网址后，具体发生了什么 HTTP，HTTPS，DNS协议 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"OSI七层模型 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"介绍一下OSI七层模型和TCP五层模型？ ​ OSI七层模型从上到下依次为： 应用层：为应用程序提供网络服务； 表示层：数据格式转换、数据压缩和数据加密； 会话层：建立、断开和维护通信链接； 传输层：为上层协议提供端到端的可靠传输； 网络层：寻址和路由； 数据链路层：定义通过通信媒介互连的设备之间传输的规范； 物理层：利用物理传输介质为数据链路层提供物理连接。 ​ TCP五层模型相比OSI七层模型，将OSI的应用层、表示层和会话层合为一层：应用层，其他不变。 ​ TCP/IP五层协议包括：应用层，传输层，网络层，数据链路层，物理层 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP,UDP,IP协议分别属于什么层？ ​ TCP，UDP协议属于传输层 ​ IP协议属于网络层 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:1:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP版本1.0,1.1,2.0 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http/1.0和http/1.1有什么区别？ ​ HTTP1.1默认开启长连接。在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 ​ 支持管道（pipeline）网络传输。只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 ​ http/1.1的缺点是服务端无法主动push ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http短连接和长连接有什么区别？ ​ HTTP中的长连接短连接指HTTP底层TCP的连接。 ​ 短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。 ​ 长连接：如果HTTP头部带有参数keep-alive，即开启长连接，网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http/2.0相比较与http/1.1有什么特性？ 多路复用。允许同时发起多重的“请求-响应”消息 头部压缩。对消息头采用 Hpack 算法进行压缩传输，能够节省消息头占用的网络流量 服务端推送。服务器端能够更快的把资源推送到客户端 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:2:3","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP报文结构，请求方法，状态码 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http请求方法有哪些？ GET: 从服务器获取资源 POST: 在服务器新建资源 PUT: 在服务器更新资源 DELETE: 在服务器删除资源 HEAD: 获取资源的元数据 OPTIONAL: 查询对指定的资源支持的方法 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"get和post方法有什么区别？ ​ Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。 ​ Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"http状态码200,403等等表示什么意思？ 1XX：接收的信息正在处理 2XX：请求正常处理完毕 3XX：重定向 4XX：客户端错误 5XX：服务端错误 200：OK 请求被正常处理 204：No Content 请求被受理但没有资源可以返回 301：永久性重定向 302：临时重定向 304：Not Modified 所请求的资源未修改，服务器返回此状态码，不返回任何资源 400：Bad Request 客户端请求报文语法有误，服务器无法识别 401：Unauthorized 请求需要认证 403：Forbidden 请求的对应资源禁止被访问 404：Not Found 服务器无法找到对应资源 500：Internal Server Error 服务器内部错误 502：Bad Gateway 网关或者代理服务器请求时，从远程服务器接收到一个无效的响应 503：Service Unavailable 服务器正忙 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:3:3","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP和HTTPS ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"HTTP和HTTPS的区别？ http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。 https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TLS技术的工作原理？ SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。 可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:4:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"DNS服务与安全 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述域名系统DNS的工作流程？ 客户端发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给本地dns服务器 本地服务器没有找到客户端查询的信息，就会将此请求发送到根域名dns服务器 根域名服务器解析客户端请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户端的dns服务器 客户端的dns服务器根据返回的信息接着访问下一级的dns服务器 这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息 客户端的本地的dns服务器会将查询结果返回给我们的客户端 客户端根据得到的ip信息访问目标主机，完成解析过程 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述cookie和session？ HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。 session用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"你了解DNS攻击吗？是什么原理？ DNS攻击主要包括DNS劫持，DNS欺骗以及DDoS攻击。 DNS劫持：通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的DNS纪录指向到黑客可以控制的DNS服务器，然后通过在该DNS服务器上添加相应域名纪录，以至于访问该域名时，进入了黑客所指向的内容。 DNS欺骗：DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了。 DDoS攻击：DDoS是一种网络攻击手法，DNS服务器本质上也是程序，黑客通常利用程序中的漏洞使目标服务器的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 TCP，UDP，IP协议 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:5:3","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"传输层协议 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:6:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TCP和UDP的区别？ TCP作为面向流的协议，提供可靠的、面向连接的传输服务，并且提供点对点通信 UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:6:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP连接及释放 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述三次握手的过程？为什么两次不行？ 第一次握手:客户端将标志位SYN置为1，随机产生一个序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。 第二次握手:服务端收到数据包后将标志位SYN和 ACK都置为1，随机产生一个序列号seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了 假如TCP建立连接是两次握手的话，那么只要服务器有回应就建立连接；如果客户端因为网络问题发送了两次或者多次请求连接的信息，那么就会建立很多次不可靠的连接；另外如果服务器在返回给客户端的ACK数据包因为网络问题导致丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁，浪费服务器资源。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP三次握手时的第一次的seq序号是怎样产生的字节提前批 第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。 seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述四次挥手的过程？为什么三次不行？ 第一次挥手：客户端将标志位FIN置为1，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。 第三次挥手：服务端标志位FIN置为1，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。 如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:3","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TIME_WAIT为什么是2MSL，而不是1MSL或者3MSL？ TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。MSL即报文最大生存时间。 设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:7:4","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"TCP的可靠连接和粘包 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TCP协议的滑动窗口？ TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，接收方通在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列，从而控制发送方的发送速度。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:1","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述TCP协议的拥塞控制及算法？ 拥塞控制是为了防止过多的数据注入到网络中，这样可能使网络中的路由器或链路负载过重，拥塞控制也是控制发送者的流量，拥塞控制有四种算法，慢启动、拥塞避免，快速重传和快速恢复 （1）慢启动。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后以指数级翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd \u003e ssthresh 时），停止使用慢开始算法而改用拥塞避免算法 （2）拥塞避免。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。 （3）快速重传。如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。 （4）快速恢复。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:2","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"拥塞控制和流量控制的区别 拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:3","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"你了解ARQ协议吗？ ARQ协议，即自动重传请求（Automatic Repeat-reQuest），意思是如果发送方在发送后一段时间之内没有收到确认回执，它通常会重新发送。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:4","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请介绍一下TCP的粘包现象以及如何避免 TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个TCP报文中发出去的可能性。 可以简单的理解成发送端调用了两次send，接收端一个recv就把信息都读出来了。 导致TCP粘包的原因主要有两方面： 发送端等待缓冲区满才进行发送，造成粘包 接收方来不及接收缓冲区内的数据，造成粘包 避免粘包的措施： 通过编程，强制使TCP进行数据传送，不必等到缓冲区满 优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等 固定发送信息长度，或在两个信息之间加入分隔符。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:5","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"请简述SYNflood攻击的原理 SYN Flood是一种拒绝服务（DDoS）攻击，其目的是通过消耗所有可用的服务器资源使服务器不可用于合法流量。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器机器上的所有可用端口，导致目标设备根本不响应合法流量。 原理是利用TCP连接三次握手的漏洞，使用欺骗性的IP地址，向目标服务器发送大量的SYN数据包 防范 第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数。 第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，并记录地址信息，以后从这个IP地址来的包会被一概丢弃。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:6","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"浏览器中输入一个网址后，具体发生了什么 首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址； 然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接； 接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送） 服务器对客户端发来的http请求进行处理，并返回响应； 客户端接收到http响应，将结果渲染展示给用户。 ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:8:7","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"参考资料 ​ 超全面的后端开发C/C++面经整理分享 ​ 计算机网络八股文背诵版 ​ 计算机网络面试题（含答案） ​ ","date":"2022-07-06","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/:9:0","tags":null,"title":"计算机网络总结 | 2022最新 ","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"边无际 | Golang后端开发 | 2022.06.25 这算是我学习go语言来第一次参加面试。 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:0:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"一面 一面是在5月份左右 自我介绍 channel关闭了去读去写会出现什么问题？这个我回答的还不错 直接两道算法题，我直接蒙逼了。 第一道是 给一些括号 匹配成功返回true，失败返回false，括号匹配问题 第二道是传入字符串键值对（a=1,b=2），转化为map型（key：value），这个就很尴尬，因为对map的不熟悉，在初始化上出了错误 中间问了 索引二叉树的时间复杂度，没有回答上来 面试完算法题就结束了，我知道结果肯定寄了，虽然一开始也没有报太大的希望 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:1:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"二面 二面主要是笔试，二套试卷，一套是go语言相关的（30道选择题和一道算法题），一套是算法题（二道），总结如下： ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"第一套试卷（后端golang） golang基本结构 golang特性 go语言触发异常的场景 CSP模型 GMP 读写锁 线程进程协程 for循环 make和new的区别 指针 引用类型 select beego框架 Gin框架 Ginkgo GoStub Go vendor Go Mock 还有没写的就是代码运行结果相关的 然后就是一道 算法题 矩阵转置 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:1","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"第二套试卷（算法） 第一道算法题是判断两棵树是否相同 第二道是合并链表 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:2","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"二面总结 题目不算太难，选择题很多库都没见过，不熟悉，最后还是很顺利的通过了笔试 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:2:3","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"三面 过完二面笔试之后，第二天收到了答复，当天晚上七点就直接进行面试（三面）。以下是面试内容 自我介绍 为什么选择Golang？前景好，性能好，小而精 擅长做什么事情？做项目 聊天室项目怎么实现的？通过几个goroutine go语言的垃圾回收？这个项目怎么进行的？ 这个项目没有用到垃圾回收，是语言的特性。 了解docker？连接简单指令，部署了聊天室的服务器 使用什么网络框架？实现了什么东西？ 登录注册 登录注册是怎么实现的？校验信息，密码加密保存 怎么进行加密的？通过github上的包 看了github项目很多，介绍写的很好，怎么写出来的？参看README模板 写两道算法题，在showmebug网站 第一道是 通过管道实现生产者消费者模型，运行出来了 第二道是 将每个单词的首字母移到至单词结尾，并在单词结尾添加「so」。保留标点符号不变。 没太写出来 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:3:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"心得 希望自己面对面试保持平常心，该干什么就干什么，不要被面试打乱了正常的学习和生活 面试前不要慌乱，这样反而准备不好 ","date":"2022-06-28","objectID":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/:4:0","tags":null,"title":"边无际 | Golang后端开发 | 2022.06.25","uri":"/%E8%BE%B9%E6%97%A0%E9%99%85golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"字节跳动 | 今日头条后端开发 | 2022.06.23 ​ 其实去字节面试也不是我主动投的简历，在牛客网上，面试官可能看到了我的简历，然后邀请我投递，我就顺手发了过去，没想到最后还成功拿到面试机会了，这让我很意外，我知道肯定没太大的希望，抱着积累面试经验的态度，我决定去试一下，以下是面试内容。 自我介绍 然后问我实习时间问了好久？ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:0:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"聊天室项目 项目怎么实现的？通过很多个goroutine 用户的消息是怎么转发给其他用户的？通过服务器的广播协程 登录注册怎么实现？ 通过什么登录（电话，邮箱）？ 服务器怎么知道是你（客户端）？网络地址 http长连接还是短连接，请求的全过程（链路） ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:1:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"go语言 GMP模型？ 怎么偷取其他的goroutine？详细说一下？ 垃圾回收机制是怎么实现的？ 乐观锁？ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:2:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"计算机基础 四次挥手 2msl 为什么不是1msl或者3msl？ 数据库 幻读了解吗？ redis几种类型 mysql索引 怎么建立索引？ 三次握手过程 外键需要索引吗 DNS解析的过程？域名服务器怎么解析？ ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:3:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"算法题 环链 直接给的main函数，没有其他东西 ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:4:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"心得 面试官问项目问的特别细，所以吸取的教训就是一定要对项目十分熟悉不然就不要写在简历上 大厂不一定需要实习经验，只要对计算机基础和算法掌握的足够深，也可以拿到offer 掌握一些前沿技术（Redis，Docker，K8S）会让自己更有竞争力 之后我也面试官问我还有其他问题吗？我就问了他，对于字节面试需要达到什么标准？对实习经验要求高吗？我还有什么不足的地方？面试官也很热心的回答了我的问题，说他们很重视计算机基础，算法，如果有一些技术特色更占优势比如redis；所以其实字节面试对应届生要求应该不会特别高 ","date":"2022-06-27","objectID":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/:5:0","tags":null,"title":"字节跳动 | 今日头条后端开发 | 2022.06.23","uri":"/%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E7%BB%8F/"},{"categories":null,"content":"目录 上手指南 开发前的配置要求 安装 文件目录说明 使用到的框架 贡献者 如何参与开源项目 版本控制 作者 鸣谢 ","date":"2022-06-24","objectID":"/blog/:1:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"上手指南 ","date":"2022-06-24","objectID":"/blog/:2:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"开发前的配置要求 go1.16以上 ","date":"2022-06-24","objectID":"/blog/:2:1","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"安装 git clone https://github.com/RobKing9/ByteGopher_SimpleDouyin.git ","date":"2022-06-24","objectID":"/blog/:2:2","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"文件目录说明 . |-- Dockerfile |-- README.md |-- controller | |-- comment.go | |-- favorite.go | |-- relation.go | |-- user.go | `-- video.go |-- dao | |-- comment.go | |-- favorite.go | |-- mysql.go | |-- relation.go | |-- user.go | `-- video.go |-- main.go |-- middleware | `-- AuthMiddleware.go |-- model | |-- comment.go | |-- common.go | |-- favorite.go | |-- follow.go | |-- user.go | `-- video.go |-- router | `-- router.go |-- tree.txt `-- utils |-- convertVideoModelListToVideoList.go |-- deleteFile.go |-- format.go |-- jwt.go |-- qiniuUpload.go |-- randNum.go `-- timetool.go ","date":"2022-06-24","objectID":"/blog/:3:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":":yum: 技术栈 Gin Gorm MySQL ","date":"2022-06-24","objectID":"/blog/:4:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"贡献者 请阅读README.md 查阅为该项目做出贡献的开发者。 ","date":"2022-06-24","objectID":"/blog/:5:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"如何参与开源项目 贡献使开源社区成为一个学习、激励和创造的绝佳场所。你所作的任何贡献都是非常感谢的。 Fork the Project Create your Feature Branch (git checkout -b feature/AmazingFeature) Commit your Changes (git commit -m 'Add some AmazingFeature') Push to the Branch (git push origin feature/AmazingFeature) Open a Pull Request ","date":"2022-06-24","objectID":"/blog/:5:1","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"版本控制 该项目使用Git进行版本管理。您可以在repository参看当前可用版本。 ","date":"2022-06-24","objectID":"/blog/:6:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"作者 曾祥文 QQ邮箱：2768817839@qq.com 您也可以在贡献者名单中参看所有参与该项目的开发者。 ","date":"2022-06-24","objectID":"/blog/:7:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"版权说明 该项目签署了MIT 授权许可，详情请参阅 LICENSE.txt ","date":"2022-06-24","objectID":"/blog/:8:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"},{"categories":null,"content":"鸣谢 字节跳动后端青训营 ","date":"2022-06-24","objectID":"/blog/:9:0","tags":null,"title":"ByteGopher_SimpleDouyin","uri":"/blog/"}]